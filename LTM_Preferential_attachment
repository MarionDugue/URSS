import networkx as nx
import random
import scipy.stats as stats
from collections import Counter
import matplotlib.pyplot as plt
from operator import itemgetter


class Simulation:
    

    def __init__(self, graph, seedset, p):
        self.seedset = seedset
        self.graph = graph
        self.num_agents = graph.number_of_nodes()
        # Create a new agent for each node, by creating an 
        #agent_map and then relabeling the nodes in the graph
        agent_map = {}
        age = Simulation.ageList(len(graph))
        house = Simulation.HouseholdList(len(graph))
        friend = Simulation.Friendships(len(graph))
        for i in range(0, self.num_agents):
            agent_map[i] = Agent(age[i], house[i], friend[i])
        nx.relabel_nodes(self.graph,agent_map,copy=False)





    # placeholder to represent a single iteration of the simulation, i.e. each agent selects a neighbour at random
    def tick(self, graph, infected_last_iteration , p):
        
        new_infected = []
        for a in graph.nodes():
            if a not in infected_last_iteration and not a.infected:
                neighbour = list(graph.neighbors(a))
                ActivatedWeights = []
                for n in neighbour:
                    if n in infected_last_iteration:
                        ActivatedWeights.append(graph[n][a]['weight'])
                SUM = sum(ActivatedWeights)
                if a.th < SUM :
                    new_infected.append(a)
        for a in new_infected:           
            a.infected = True
        return new_infected
                    
    def ageList(population_size):
        Count_Age65_plus = round(population_size * 25/85)
        Count_Age18_34 = round(population_size *0.5* (46*63/48)/85)
        Count_Age35_64 = Count_Age18_34
        AgeList = []
        
        for i in range(0,Count_Age18_34):
            n = random.randint(18,34)
            AgeList.append(n)
        for i in range(0,Count_Age35_64):
            n = random.randint(35,64)
            AgeList.append(n)
        for i in range(0,Count_Age65_plus):
            n = random.randint(65,100)
            AgeList.append(n)
        Reversed_AgeList = AgeList[::-1]
        Truncated_Reversed_AgeList = Reversed_AgeList[:population_size]
        AgeList = Truncated_Reversed_AgeList[::-1]
        return AgeList
    
    def HouseholdList(population_size):
        Household_List = []
        Household_List_18_to_34 = []
        Household_List_34_to_64 = []
        Household_List_65_plus = []
        #For 18 to 34 years old, mu = 1.54
        Count_Age18_34 = round(population_size *0.5* (46*63/48)/85)
        House18_to_34 =  stats.poisson.rvs( 1.54, loc = 0, size=Count_Age18_34)
        for i in range(0,Count_Age18_34):
            Household_List_18_to_34.append(House18_to_34[i])
        #For 35 to 64 years old, mu = 1.69
        Count_Age35_64 = Count_Age18_34
        House35_to_64 =  stats.poisson.rvs( 1.69, loc = 0, size=Count_Age35_64)
        for i in range(0,Count_Age35_64):
            Household_List_34_to_64.append(House35_to_64[i])
        #For 65+ years old, mu = 0.49
        Count_Age65_plus = round(population_size * 25/85)
        House64_plus =  stats.poisson.rvs( 0.49, loc = 0, size=Count_Age65_plus)
        for i in range(0,Count_Age65_plus):
            Household_List_65_plus.append(House64_plus[i])
        Sensible_18_to_34 = Simulation.SensibleHouseholds(Household_List_18_to_34)
        Sensible_34_to_64 = Simulation.SensibleHouseholds(Household_List_34_to_64)
        Sensible_65_plus = Simulation.SensibleHouseholds(Household_List_65_plus)
        Household_List = Sensible_18_to_34 + Sensible_34_to_64 + Sensible_65_plus
        
        #Because the values are decimals, we want exactly length of population_size:
        #The UK population is ageing so we remove values from the 18-34 section
        Reversed_Household_List = Household_List[::-1]
        Truncated_Reversed_Household_List = Reversed_Household_List[:population_size]
        Household_List = Truncated_Reversed_Household_List[::-1]
        return Household_List
        

    def SensibleHouseholds(Household_List_depending_on_age):
        #------------------------CHECKING WHICH VALUE IS SENSIBLE------------
        #--Counts each value in Household_List and creates a dictionary---------------------
        
        Household_Dict = dict(Counter(Household_List_depending_on_age))
        
        
        #--Checking for multiples--------------------------------------------  
             
        Not_sensible = {}
        for size in Household_Dict:
            if size != 0:
                if size == 1:
                    if Household_Dict[size] % 2 != 0:
                        Not_sensible[size] = Household_Dict[size]
                else:
                    if Household_Dict[size] == 1:
                        Not_sensible[size] = Household_Dict[size]
                    else:
                        if Household_Dict[size] % (size+1) != 0:
                            Not_sensible[size] = Household_Dict[size]
        
        #--Sorting values of Not_sensible & Household dictionary-------------------------------------            
        SNot_List = sorted(Not_sensible.items(), key=lambda x: x[0], reverse=True)
        Sorted_Household =  sorted(Household_Dict.items(), key=lambda x: x[0])
        
        
        
        #--If pair is not sensible, its count will be carried out to the next one-----------------
        credit = 0
        newpairs = []
        
        for pair in SNot_List:
            key = pair[0]
            
            if credit != 0:
                value = pair[1] + credit 
                credit = 0
                
            else:
                value = pair[1]
            if key == 1:
                if value % 2 != 0:
                    value = value - 1
                    Value_0 = Sorted_Household[0][1] + 1
                    newpairs.append((Sorted_Household[0][0], Value_0))
                    newpairs.append((Sorted_Household[1][0], value))
                else:
                    newpairs.append((key, value))
            else:
                if value == 1:
                        value = 0
                        credit += 1
                        newpairs.append((key, value))
                if value == 0:
                    newpairs.append((key, value))
                else:
                    if value % (key+1) != 0:
                        while value % (key+1) != 0:
                            value = value - 1
                            credit += 1
                        newpairs.append((key, value))
                        if SNot_List[-1] == pair:
                            for pair in Sorted_Household:
                                if pair[0] == 1:
                                    value = pair[1] + credit
                                    if value % 2 != 0:
                                        value = value - 1
                                        Value_0 = Sorted_Household[0][1] + 1
                                        newpairs.append((Sorted_Household[1][0], value))
                                        newpairs.append((Sorted_Household[0][0], Value_0))
                                    else:
                                        newpairs.append((Sorted_Household[1][0], value))
                        
                    else:
                        newpairs.append((key, value))
        
        
        #--Appending sensible pairs to the new list------------------------------------    
        
        i = 0
        while i < len(Sorted_Household):
            a = Sorted_Household[i][0]
            j = 0
            for x in newpairs:
                m = x[0]
                if a == m :
                    j = 1
            if j == 0:
                newpairs.append(Sorted_Household[i])
            i += 1
        
        #--Removing all pairs with a count = 0-----------------------------------------
            
        Cleaned_newpairs=[]
        for n in range(0,len(newpairs)):
            if newpairs[n][1] != 0:
                Cleaned_newpairs.append(newpairs[n])
           
        
            
        
        #--Transforming List of pairs into list of integers---------------------------      
        
        New_Householdlist = []
        for pair in Cleaned_newpairs:
            i = 0
            while i < pair[1]:
                New_Householdlist.append(pair[0])
                i += 1
        return New_Householdlist
    
    def Friendships(population_size):
        Friends_List = []
        #(we assume at first) that everyone has 0 to 20 friends with an average at 3-5
        Friends_List =  stats.poisson.rvs( 4, loc = 0, size=population_size)
        if sum(Friends_List) % 2 != 0:
            Friends_List[0] = Friends_List[0] + 1        
        return Friends_List
            
class Agent:
    idCounter = 0
    threshold = random.uniform(0,1)
    infected = False  
    age = 0
    housesize = 0
    housefull = False
    friends = 0
    friendshipfull = False


    def __init__(self, start_age, start_household, start_friends):
        # set id and ensure each agent has unique id
        self.id = self.idCounter
        type(self).idCounter += 1
        # set threshold and ensure each agent has unique threshold
        self.th = self.threshold
        type(self).threshold = random.uniform(0,1)
        #set age
        self.age = start_age
        #set houselhold size
        self.housesize = start_household
        #set number of friends
        self.friends = start_friends

    def __str__(self):
        return "agent_" + str(self.id)

    def __repr__(self):
        return "agent_" + str(self.id)



#--------------------------------------------------------------
population_size = 10

#-------------------------------------------------
G = nx.Graph()
for i in range(0,population_size):
    G.add_node(i)

#-----------------------------------------------------------------------

#Creating random seedset with k length
k = 10
new_infected = []


#Parameter of system
p = 0.1 
s = Simulation(G, [], p)
initial_seedset = random.sample(s.graph.nodes, k)

#---Creating freindship network-------------------

Dict_of_Friendships = {}
Zero_friends_list = []
Filtered_friends = []
for node in G.nodes():
    Dict_of_Friendships[node.id] = node.friends
Zero_friends_list = {i:Dict_of_Friendships[i] for i in Dict_of_Friendships if Dict_of_Friendships[i]==0}
print("ZERO IS",Zero_friends_list )
Filtered_friends = {i:Dict_of_Friendships[i] for i in Dict_of_Friendships if Dict_of_Friendships[i] !=0}

    #Get dictionary of node ids and associated friend number with largest friend number first

Sorted_Reverse_FFriends = {k: v for k, v in sorted(Filtered_friends.items(), key=lambda item: item[1], reverse=True)}
print("SORTED IS",Sorted_Reverse_FFriends )
Sorted_FFriends = {k: v for k, v in sorted(Filtered_friends.items(), key=lambda item: item[1])}
print("SORTED is",Sorted_FFriends)

     #--Initial edge is between the nodes wit the 2 largest number of friends------
u = list(Sorted_Reverse_FFriends.keys())[0]
v = list(Sorted_Reverse_FFriends.keys())[1]
    
print("INITIAL CONNECTED ARE", u,v)
for node in G.nodes:
    if node.id == u:
        Node1 = node
    if node.id == v:
        Node2 = node

G.add_edge(Node1, Node2)


def Modified_Barabasi(G):
    Full_Friends = {}
    for nodeID in Sorted_FFriends:
        for node in G.nodes():
            if node.id == nodeID:
                if node.friendshipfull == True:
                    if node.id not in Full_Friends:
                        Full_Friends[node.id] = node.friendshipfull
                    continue
                else:
                    print("THIS IS FOR NODE", node.id)
                    print("DEGREE now", G.degree(node))
                    print("Friendship ", node.friends )
                    #Get a dictionary of degrees
                    degrees = nx.degree(G)
                    
                    #Maitain a dictionary of proabilities
                    node_probabilities = {}
                    for each in G.nodes():
                        node_probabilities[each] = (float)(degrees[each])/sum(dict(G.degree()).values())
                    
                    node_probabilities_cum = []
                    prev = 0
                    
                    for n,p in node_probabilities.items():
                        temp = [n, prev + p]
                        node_probabilities_cum.append(temp)
                        prev = prev + p
                        
                    node_probabilities = list(node_probabilities.items())
                    Sorted_probabilities = sorted(node_probabilities, key=itemgetter(1))
                    print("SORTED PROBA ARE", Sorted_probabilities)
                    
                    new_edges = []
                    num_edges_added = 0
                    target_nodes = []
                    # for each in G.nodes():
                  
                    
                    #Mainting lists of list of cumulative node probabilities
                    node_probabilities_cum = []
                    prev = 0
                    for n,p in Sorted_probabilities:
                        temp = [n, prev + p]
                        node_probabilities_cum.append(temp)
                        prev = prev + p
                    Filtered_Cum_List = []
                    for pair in node_probabilities_cum:
                        if pair[1] != 0:
                            Filtered_Cum_List.append(pair)
                    #adding edges
                    new_edges = []
                    num_edges_added = 0
                    target_nodes = []
                    while(num_edges_added < node.friends):
                        prev_cum = 0
                        r = random.random()
                        k = 0
                        MAX = len(Filtered_Cum_List)
                        if r > Filtered_Cum_List[MAX-1][1]:
                            r = random.random()
                        while (not(r > prev_cum and r <= Filtered_Cum_List[k][1])):
                            prev_cum = Filtered_Cum_List[k][1]
                            k += 1
                          
                        
                        target_node = Filtered_Cum_List[k][0]
                        
                        #Checking it doesnt connect to a filled node:
                        
                        i = 1
                        if target_node.friendshipfull == True:
                            target_node =  Filtered_Cum_List[k-i][0]
                            i += 1
                            if i == k:
                                continue
                      
                        print("TARGET",target_node )
                        if target_node in target_nodes:
                            print("LOOP BACK")
                            
                        else:
                            target_nodes.append(target_node)
                        if target_node.friendshipfull == False:
                            G.add_edge(node, target_node, key ='Friends')
                            num_edges_added += 1 #stops loop
                            new_edges.append((node, target_node))
                            print("EDGE HAS BEEN ADDED")
                        if G.degree(target_node) == target_node.friends:
                            target_node.friendshipfull = True
                        if G.degree(node) == node.friends:
                            node.friendshipfull = True
                            if node.id not in Full_Friends:
                                Full_Friends[node.id] = node.friendshipfull
                                
                        continue

                    print(num_edges_added, 'edges added')
    nx.draw(G)
    return G

Modified_Barabasi(G)

#------Creating network for households---------------------------
# for agt in G.nodes:
#     if agt.housesize != 0:
#         for neighbr in G.nodes:
#             if agt.id != neighbr.id:
#                   if agt.housesize == neighbr.housesize:
#                       if agt.housefull == False and neighbr.housefull == False:
#                           G.add_edge(agt,neighbr,color='b', weight=3)
#                           if G.degree(agt, weight=3) == agt.housesize:
#                               agt.housefull = True
#                           if G.degree(neighbr) == neighbr.housesize:
#                               neighbr.housefull = True
                              



# edges = G.edges()
# colors = [G[u][v]['color'] for u,v in edges]
# weights = [G[u][v]['weight'] for u,v in edges]
# pos = nx.circular_layout(G)
# nx.draw(G,pos,  edges=edges, edge_color=colors, width=weights)                               
# plt.legend(['Agents', 'Household'])


      
#----------------------------------------------------------------- 
# cache each agent's neighbor list - could looked up each time depending what you are doing
for n in s.graph.nodes():
    n.neighbors = [agt for agt in s.graph.neighbors(n)]
    #print(n.neighbors)
    
#Assigning weights
for u in G.nodes():
    neighbour = list(G.neighbors(u))
    Edge_list = []
    for n in neighbour:
        #Generating x weights for x neighbours of node n 
        G[u][n]['weight'] = random.uniform(0,10)
        Edge_list.append(G[u][n]['weight'])
    #Sum edges to get total
    Sum_Edges= sum(Edge_list)
    for n in neighbour: 
        G[u][n]['weight'] = (G[u][n]['weight'])/Sum_Edges   

# run the simulation for appropriate number of iterations
#t iterations
t = 1000
previous_infections = initial_seedset
for i in range(0,t):
    new_infections = s.tick(G, previous_infections, p)
    print("iteration ", i, " number of new infections: ", len(new_infections))
    if not new_infections:
        break
    previous_infections = new_infections

#---------------------------
